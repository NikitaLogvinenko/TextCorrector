#ifndef _FILES_WORKING_
#define _FILES_WORKING_


#include <stdio.h>
#include <stdbool.h>


// Создать временный файл tmp_file_name и открыть его в режиме open_mode. Используется для создания временного файла с параметрами для конфигурации в cfg_from_params.
// В случае ошибки создания или открытия вернёт NULL (при этом если файл создался, но не открылся, он будет сразу удалён; если удаление не удалось - сообщаем пользователю)
// В случае успешного создания и открытия возвращаем указатель на открытый файл
// tmp_file_name - ОТНОСИТЕЛЬНЫЙ ПУТЬ!!! Временный файл создаётся в директории, из которой открыта программа 
FILE* create_and_open_tmp(const char* tmp_file_name, const char* open_mode);

// Проверить, является ли файл path_to_cfg временным файлом с конфигурацией. Если да, то удалить его. Файл должен быть закрыт заранее
void delete_if_tmp(const char* path_to_cfg);

// Проверить, что файл file_name (вместе с его абсолютным или относительным путём) существует
bool file_exists(const char* file_name);

// Создать файл. Если файл с таким именем уже существует - пользователю выводится соответствующее сообщение error_msg, а новый файл создан не будет
// file_name должен быть относительным или абсолютным путём и включать в себя имя создаваемого файла
// В случае неудачи возвращается false и выводится error_msg (если произошла аппаратная ошибка)
bool file_create(const char* file_name, const char* error_msg);

// Удалить файл
// file_name должен быть относительным или абсолютным путём и включать в себя имя удаляемого файла
// В случае неудачи возвращается false и выводится error_msg
bool file_remove(const char* file_name, const char* error_msg);

// Записать в файл file strings_amount записей из strings_for_writing. Предполагается, что файл открыт в нужном режиме (запись или дозапись). ФАЙЛ НЕ ЗАКРЫВАЕТСЯ ПО ОКОНЧАНИИ ЗАПИСИ!!!
// Если file == NULL, то ничего записываться не будет, но вернётся false
// В начало и конец каждой записи добавляется shell (если NULL, то ничего не добавляется)
// Строка-разделитель между записями - delimiter (если NULL, то все записи вводятся слитно)
// В конце всех записей ввести end (если NULL, то в конце не добавляется ничего).
// ПЕРЕД ПЕРВОЙ ЗАПИСЬЮ НЕ СТАВИТСЯ DELIMETER! Если нужно отделить предыдущие записи (записанные до вызова функции) от новых, надо добавить разделитель в первую запись.
// ПЕРЕД END НЕ СТАВИТСЯ DELIMETER! Если нужно разделить последний ввод и end разделителем, надо добавить разделитель в end
// В случае неудачной записи вернёт false
bool file_write(FILE* file, unsigned strings_amount, const char** strings_for_writing, const char* shell, const char* delimeter, const char* end);

// Получает относительный путь к файлу (вместе с именем) rel_name. Возвращает абсолютный путь. Память выделяется динамически!
// Если rel_name == NULL, то возвращает путь к рабочей директории. В случае ошибки возвращает NULL
// Если всё прошло без ошибок и print_way == true, то ещё и напечатает этот путь в консоль
// Если print_errors == true, то печатает об ошибках в консоль, иначе ничего не печатает при ошибках и возвращает NULL
char* rel_to_abs_way(const char* rel_name, bool print_way, bool print_errors);

// Читаем посимвольно параметр из файла file_from. Файл уже должен быть открыт на чтение, а каретка должна стоять в нужном месте. По завершении чтения параметра файл не закрывается
// Пропускаем символы до первого непробельного или EOF (int isspace(int c) - возвращает true, если с — пробельный символ: пробел, новая строка,перевод страницы, 
// возврат каретки, вертикальная табуляция, горизонтальная табуляция или, возможно, другой символ, определяемый реализацией
// Если пользователь некорректно ввёл параметр (есть открывающие, но нет закрывающих кавычек, или встречен EOF до начала чтения параметра), возвращаем EXIT_USER_FAILURE
// Если встречены открывающие кавычки - записываем в buffer последующие символы до закрывающих двойных кавычек ", EOF или переполнения буфера.
// Если после пробела идут не кавычки, то параметр считывается до следующего пробела
// В случае переполнения буфера возвращаем EXIT_MEMORY_FAILURE
// Если встречены и открывающие, и закрывающие двойные кавычки, то чтение параметра прошло успешно и возвращается EXIT_SUCCESSFULLY
// Если после всех операций в buffer останутся кавычки - вернуть EXIT_USER_FAILURE (в параметрах кавычек быть не должно)
int read_param_from_file(FILE* file_from, char* buffer, size_t buffer_size);

// Проверяет, что путь заканчивается на .txt. Путь НЕ должен быть заключён в кавычки
bool path_is_txt(const char* path);


#endif