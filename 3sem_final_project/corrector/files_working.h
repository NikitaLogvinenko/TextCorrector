#ifndef _FILES_WORKING_
#define _FILES_WORKING_


#include <stdio.h>
#include <stdbool.h>


// Создать файл
// file_name должен быть относительным или абсолютным путём и включать в себя имя создаваемого файла
// В случае неудачи возвращается false и выводится error_msg
bool file_create(const char* file_name, const char* error_msg);

// Удалить файл
// file_name должен быть относительным или абсолютным путём и включать в себя имя удаляемого файла
// В случае неудачи возвращается false и выводится error_msg
bool file_remove(const char* file_name, const char* error_msg);

// Записать в файл file strings_amount записей strings_for_writing. Предполагается, что файл открыт в нужном режиме (запись или дозапись). ФАЙЛ НЕ ЗАКРЫВАЕТСЯ ПО ОКОНЧАНИИ ЗАПИСИ!!!
// Если file == NULL, то ничего записываться не будет, но вернётся false
// В начало и конец каждой записи добавляется shell (если NULL, то ничего не добавляется ("\0"))
// Строка-разделитель между записями - delimiter (если NULL, то все записи вводятся слитно ("\0"))
// В конце всех записей ввести end (если NULL, то в конце не добавляется ничего ("\0")).
// ПЕРЕД ПЕРВОЙ ЗАПИСЬЮ НЕ СТАВИТСЯ DELIMETER! Если нужно отделить предыдущие записи от новых, надо добавить разделитель в первую запись.
// ПЕРЕД END НЕ СТАВИТСЯ DELIMETER! Если нужно разделить последний ввод и end разделителем, надо добавить разделитель в end
// В случае неудачи вернёт false
bool file_write(FILE* file, unsigned strings_amount, const char** strings_for_writing, const char* shell, const char* delimeter, const char* end);

// Получает относительный путь к файлу (вместе с именем) rel_name. Возвращает абсолютный путь. Память выделяется динамически!
// Если rel_name == NULL, то возвращает путь к рабочей директории. В случае ошибки возвращает NULL
// Если всё прошло без ошибок и print_way == true, то ещё и напечатает этот путь в консоль
// Если print_errors == true, то печатает об ошибках в консоль, иначе ничего не печатает при ошибках и возвращает NULL
char* rel_to_abs_way(const char* rel_name, bool print_way, bool print_errors);

// Читаем посимвольно файл file_from. Файл уже должен быть открыт на чтение. По завершении чтения параметра файл не закрывается
// Пропускаем символы до первого непробельного или EOF
// Если на каком-то этапе встречаем EOF - значит пользователь некорректно ввёл параметр, возвращаем EXIT_USER_FAILURE
// Если встречены открывающие кавычки - записываем в buffer последующие символы до закрывающих двойных кавычек ", EOF или переполнения буфера.
// Если после пробела идут не кавычки, то параметр считывается до следующего пробела
// В случае переполнения буфера возвращаем EXIT_MEMORY_FAILURE
// Если встречены и открывающие, и закрывающие двойные кавычки, то чтение параметра прошло успешно и возвращается EXIT_SUCCESSFULLY
// Если после всех операций в buffer остануться кавычки - вернуть EXIT_USER_FAILURE
int read_param_from_file(FILE* file_from, char* buffer, size_t buffer_size);


#endif