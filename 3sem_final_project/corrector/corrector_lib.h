#ifndef _CORRECTOR_LIB_
#define _CORRECTOR_LIB_


#include "CorrectorModel.h"
#include <stdio.h>


// Инициализация корректора. Создание таблиц. Установка функции поиска разности слов (стандартно - расстояние Хэмминга)
// В случае успешного выделения памяти под таблицы возвращает EXIT_SUCCESSFULLY, иначе EXIT_MEMORY_FAILURE
int corrector_init(Corrector* corrector, unsigned max_word_length, WordsMetric metric_func);

// Очистка таблиц в корректоре
// Обратите внимание, чистятся только таблицы. Если память под сам корректор выделялась динамически - необходимо самостотельно выполнить free(corrector)
void corrector_destroy(Corrector* corrector);

// Сохранение ОБУЧЕННОЙ модели в файл model_file_name. Запись осуществляется в формате:
// max_word_length=mwl
// <table_1> ...
// <table_2> ...
// ...
// <table_mwl> ...
// По окончании записи закрывает файл
// В случае успешного сохранения возвращает EXIT_SUCCESSFULLY
// Если model_file_name не является путём к файлу .txt - вернёт EXIT_USER_FAILURE
// Если не открылся файл - вернёт EXIT_FILE_FAILURE
int corrector_save(Corrector* corrector, const char* model_file_name);

// Записать слово в соответствующую таблицу в корректоре. Установить счётчик слова в 1, если это новое слово, или увеличить счётчик существующего слова на 1
// Память под слово должна выделяться динамически. Если память под узел для слова не выделится или такое слово уже было в таблице - память word чистится в функции mlist_add внутри
// Если слово успешно записано - вернёт EXIT_SUCCESSFULLY
// Если указатель на модель или на слово равны NULL - вернёт EXIT_USER_FAILURE
// Если слово слишком длинное для таблицы - вернёт EXIT_TOO_LONG
// Если не выделилась память под узел для нового слова, то модель остаётся прежней, а функция вернёт EXIT_MEMORY_FAILURE
int corrector_learn(Corrector* corrector, const char* word);

// Загрузить обученную модель из файла model_file_name в НЕИНИЦИАЛИЗИРОВАННУЮ модель (если модель уже инициализирована - она будет перезаписана, однако вероятны утечки памяти)
// Из файла считывается max_word_length и модель инициализируется, создаётся нужное количество таблиц. Далее таблицы заполняются словами из файла
// Если модель успешно загружена - вернуть EXIT_SUCCESSFULLY
// Если не выделилась память под изначальные таблицы или под таблицы нужного размера - вернуть EXIT_MEMORY_FAILURE. В таком случае все прочитанные данные также чистятся
// Если файл не открылся - вернуть EXIT_FILE_FAILURE
// Если файл имеет неправильный формат - вернуть EXIT_USER_FAILURE
// Если модель или имя файла указывают на NULL, или имя файла не является путём к файлу .txt - вернуть EXIT_USER_FAILURE
int corrector_load(Corrector* corrector, const char* model_file_name);

// Получает прочитанное слово, хранящееся в initial_buffer, которое, возможно, нужно отредактировать. Отредактированное или нет - слово выводится в edited_file.
// Возвращает последний выведенный в файл edited_file символ.
// Первый символ слова должен быть гарантированно буквой. Далее идут до corrector->max_word_length - 1 включительно букв и дефисов. 
// Также возможен один небуквенный и недефисный символ в конце (ЛЮБОЙ, не обязательно пунктуационный; может быть, например, цифра).
// Из corrector->max_word_length символов все кроме первого могут быть дефисами, в т.ч. допустимо, чтобы все символы кроме первого были дефисами.
// Все дефисы в конце слова и небуквенный символ (если он есть) исключаются при редактировании из рассмотрения и после редактирования и записи слова выводятся после него.
// Корректор сначала проверяет существование слова в своей памяти. Если такого нет, то пытается отредактировать в соответствии с size_tol и threshold (см. README.md, параметры).
// Если получается отреактировать и указатель words_edited_counter не NULL, то увеличивает счётчик отредактированных слов на единицу. В противном случае записывает слово без изменений.
// Если в слове одна буква - оно не редактируется. 
// Дефисы скраю слов считаются самостоятельными символами.
// Если в слове более одной заглавной буквы, и первая тоже заглавная, то предполагается, что это какое-то сокращение или аббревиатура, и слово остаётся без изменений.
// Если первая буква прописная, то все остальные заглавные заменяются на прописную.
// Если только первая буква заглавная, то отредактированное слово тоже будет с заглавной буквы.
// edited_buffer используется для хранения слова в нижнем регистре при подборе вариантов редактирования (все слова в corrector хранятся в нижнем регистре)
int corrector_edit(Corrector* corrector, const char* initial_buffer, char* edited_buffer, FILE* edited_file, unsigned size_tol, unsigned threshold, unsigned* words_edited_counter);


#endif 

