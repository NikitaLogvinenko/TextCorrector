#ifndef _WORDS_HANDLING_
#define _WORDS_HANDLING_


#include <stdio.h>
#include <stdbool.h>


// Поиск разницы слов как количество различающихся символов (если слова разной длины, то все лишние символы в более длинном слове считаются отличающимися)
unsigned hamming_distance(const char* word1, const char* word2);

// Переводит слово в верхний регистр. Все небуквенные символы остаются как есть
// Возвращает число заменённых букв. Если initial_word или editted_word равны NULL - вернёт -1
int word_to_upper(const char* initial_word, char* editted_word);

// Переводит слово в нижний регистр. Все небуквенные символы остаются как есть
// Возвращает число заменённых букв. Если initial_word или editted_word равны NULL - вернёт -1
int word_to_lower(const char* initial_word, char* editted_word);

// Переводит букву в верхний регистр
// Принимает код символа и возвращает код заглавной буквы
// Если передана не буква, то вернёт тот же код
int letter_to_upper(int code);

// Переводит букву в нижний регистр
// Принимает код символа и возвращает код строчной буквы
// Если передана не буква, то вернёт тот же код
int letter_to_lower(int code);

// Провяет по коду символа, является ли он буквой русского или английского алфавита
bool is_letter(int code);

// Проверяет по коду символа, что это буква английского алфавита
bool is_eng_letter(int code);

// Проверяет по коду символа, что это буква русского алфавита
bool is_rus_letter(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой русского или английского алфавита
bool is_upper_letter(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой русского или английского алфавита
bool is_lower_letter(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой английского алфавита
bool is_upper_letter_eng(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой английского алфавита
bool is_lower_letter_eng(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой русского алфавита
bool is_upper_letter_rus(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой русского алфавита
bool is_lower_letter_rus(int code);

// Считывает слово из файла в буфер. Слово предназначается для обучения модели
// Пропускает пробельные и пунктуационные символы, пока не встретит первый непробельный и непунктуационный
// Затем считывает до max_word_length символов включительно и в конце ставит '\0' (т.е. в буффере должно быть место минимум на max_word_length+1 символов)
// Считывание идёт, пока не считаем max_word_length символов или не встретится новый пробельный/пунктуационный символ/EOF
// Если слово не превысило max_word_length - его изучать не надо. Считываем все оставшиеся символы до нового пробельного, а буфер очищаем (ставим '\0' в начало)
// Возвращает true, если конец файла ещё не достигнут, иначе возвращает false
bool read_train_word(FILE* text_file, char* buffer, unsigned max_word_length);

// Получает слово для обучения. Возвращает указатель на отредактированное слово. Память под слово выделена динамически. Далее это слово будет сохранено в таблице
// Если слово не подходит для обучения, то возвращает NULL, иначе подготавливает слово для обучения и возвращает указатель на отредактированное слово
// Чтобы слово изучалось, оно должно состоять только из букв и дефисов (знаки препинания в начале и в конце слова отброшены при чтении)
// Если слово состоит только из букв и дефисов, то все буквы приводятся к нижнему регистру
const char* prepare_train_word(const char* word);

// Считает количество небуквенных символов (дефис считается буквой) в слове
int wrong_symbols_in_word(const char* word);

// Считает количество букв и дефисов в слове
int letters_and_hyphens_in_word(const char* word);


#endif 

