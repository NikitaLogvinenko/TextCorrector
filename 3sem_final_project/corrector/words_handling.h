#ifndef _WORDS_HANDLING_
#define _WORDS_HANDLING_


#include "CorrectorModel.h"
#include <stdio.h>
#include <stdbool.h>


// Поиск разницы слов как количество различающихся символов (если слова разной длины, то все лишние символы в более длинном слове считаются отличающимися)
unsigned hamming_distance(const char* word1, const char* word2);

// Переводит слово в верхний регистр. Все небуквенные символы остаются как есть
// Возвращает число заменённых букв. Если initial_word или edited_word равны NULL - вернёт -1
int word_to_upper(const char* initial_word, char* edited_word);

// Переводит слово в нижний регистр. Все небуквенные символы остаются как есть
// Возвращает число заменённых букв. Если initial_word или edited_word равны NULL - вернёт -1
int word_to_lower(const char* initial_word, char* edited_word);

// Переводит букву в верхний регистр
// Принимает код символа и возвращает код заглавной буквы
// Если передана не буква, то вернёт тот же код
int letter_to_upper(int code);

// Переводит букву в нижний регистр
// Принимает код символа и возвращает код строчной буквы
// Если передана не буква, то вернёт тот же код
int letter_to_lower(int code);

// Проверяет по коду символа, является ли он буквой русского или английского алфавита
bool is_letter(int code);

// Проверяет по коду символа, что это буква английского алфавита
bool is_eng_letter(int code);

// Проверяет по коду символа, что это буква русского алфавита
bool is_rus_letter(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой русского или английского алфавита
bool is_upper_letter(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой русского или английского алфавита
bool is_lower_letter(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой английского алфавита
bool is_upper_letter_eng(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой английского алфавита
bool is_lower_letter_eng(int code);

// Проверяет по коду символа, является ли он ЗАГЛАВНОЙ буквой русского алфавита
bool is_upper_letter_rus(int code);

// Проверяет по коду символа, является ли он СТРОЧНОЙ буквой русского алфавита
bool is_lower_letter_rus(int code);

// Получает слово для обучения. Возвращает указатель на отредактированное слово. Память под слово выделяется динамически. Далее это слово будет сохранено в таблице.
// Если слово не подходит для обучения, то возвращает NULL, иначе подготавливает слово для обучения и возвращает указатель на отредактированное слово.
// Слово подходит для обучения, если оно состоит только из букв и дефисов, при этом никакие два дефиса не идут подряд. В таком случае все буквы приводятся к нижнему регистру.
// При этом слово не может состоять только из дефисов, т.к. дефисы (как и все остальные пунктуационные и пробельные символы) в начале и в конце слова 
// отбрасываются в read_train_word() (static функция в модуле train_module.c) => по краям дефисов нет, а значит слово не только из дефисов.
// Если word == NULL или word == "\0", то также возвращается NULL.
// Все пунктуационные (кроме дефисов внутри слова) и пробельные символы должны быть отброшены заранее 
// (например, при чтении файла для обучения это делает static функция read_train_word() в модуле train_module.c).
const char* prepare_train_word(const char* word);

// Считает количество небуквенных символов (дефис считается буквой) в слове
int wrong_symbols_in_word(const char* word);

// Считает количество букв и дефисов в слове
int letters_and_hyphens_in_word(const char* word);

// Считает количество букв в слове
int letters_in_word(const char* word);

// По коду символа определяет, нужен ли после него пробел перед словом.
// // symbol_code должен быть для UNSIGNED char! Тип int сделан только для того, чтобы поддерживать EOF, который <0.
// Символы, не требующие пробел: "'`~([{<\|/@#$&_
// Также все пробельные символы не требуют после себя пробела.
// После EOF также пробел не нужен. Если в функцию передан любой другой отрицательный код, кроме EOF, вернётся true.
bool space_demanding(int symbol_code);

// Принимает код символа и если он меньше 0, то переводит в код unsigned char. Возвращает код unsigned
unsigned signed_to_unsigned_char(int code);

// Если symbol_code - буква, а prev_code - непробельный символ, требующий после себя пробел, то вывести в edited_file пробел и вернуть (int)' '
// В противном случае ничего не выводить в файл и вернуть prev_code
int space_before(FILE* edited_file, int prev_code, int symbol_code);

// Получает на вход строку string_with_punct, ограниченную нуль-терминатором.
// Функция "затирает" нулями '\0' все подряд идущие пунктуационные знаки в конце (в т.ч. дефисы).
// Возвращает новый индекс нуль-терминатора (т.е. в какой позиции стоял первый пунктуационный знак в конце строки).
// Если string == NULL или string == "\0", то вернёт 0.
int erase_punct_remainder(char* string_with_punct);

// Получает на вход строку string_with_punct, ограниченную нуль-терминатором.
// Функция "затирает" нулями '\0' все подряд идущие небуквенные знаки в конце (в т.ч. дефисы).
// Возвращает новый индекс нуль-терминатора (т.е. в какой позиции стоял первый небуквенный знак в конце строки).
// Если string == NULL или string == "\0", то вернёт 0.
int erase_not_letter_remainder(char* string_with_punct);

// Проверяет, есть ли в слове подряд идущие дефисы.
// Если word == NULL или word == "\0" - вернёт false.
bool has_double_hyphens(const char* word);

// Считает количество заглавных букв в слове. Если word == NULL, то возвращает 0.
int capital_counter(const char* word);


#endif 

