#ifndef _CONSTANTS_
#define _CONSTANTS_


// Чтобы во всех файлах был доступен ввод с консоли через scanf
#define _CRT_SECURE_NO_WARNINGS

// Извинение за ошибку работы с памятью
#define APOLOGY_MEMORY_MSG "Ошибка работы с памятью(((\nБлагодарим Вас за использование приложения!\nПопробуйте ещё раз\n"
// Количество повторных попыток выделения динамической памяти
#define MAX_MALLOC_ATTEMPTS 3
// Количество попыток пользователю ввести что-то в консоль
#define MAX_USER_ATTEMPTS 5
// Программа успешно отработала
#define EXIT_SUCCESSFULLY 0
// Ошибка по вине пользователя
#define EXIT_USER_FAILURE 1
// Ошибка выделения памяти
#define EXIT_MEMORY_FAILURE 2
// Ошибка работы с файлами
#define EXIT_FILE_FAILURE 3
// Не удалось определить индекс строки в хеш-таблице, в которой должно быть слово (хеш-таблица не инициализирована или указатель слова равен NULL)
#define EXIT_INDEX_FAILURE -1
// Слова не было в таблице
#define EXIT_ABSENT -2
// Возвращаемое значение из corrector_learn() в случае, если длина слова превышает допустимую длину слова модели
#define EXIT_TOO_LONG -3

// Невозможный путь для создания файла .txt (в функции проверки пути проверяется, что путь оканчивается на .txt"
#define WRONG_PATH "wrong path"
// Неправильно введённый параметр (все параметры модели должны быть неотрицательными)
#define WRONG_PARAM -1
// Задаём конфигурацию через параметры
#define CFG_FROM_PARAMS 0
// Задаём конфигурацию последовательно через консоль
#define CFG_STEP_BY_STEP 1
// Задаём конфигурацию в файле
#define CFG_FROM_FILE 2
// Вывести справку
#define PRINT_HELP 3

// Неизвестный режим
#define WRONG_MODE -1
// Режим обучения новой модели
#define TRAIN_NEW_MODE 0
// Режим дообучения существующей модели
#define TRAIN_EXISTED_MODE 1
// Режим редактирования текста
#define EDIT_MODE 2
// Сколько всего режимов работы
#define MODES_AMOUNT 3

// Число параметров в конфиге в режиме TRAIN_NEW
#define TRAIN_NEW_CFG_SIZE 4
// Число параметров в конфиге в режиме TRAIN_EXISTED
#define TRAIN_EXISTED_CFG_SIZE 3
// Число параметров в конфиге в режиме EDIT
#define EDIT_CFG_SIZE 6

// Сколько памяти выделить под буфер для строки, считываемой из файла или из консоли (5600 - столько символов умещается на страничке WORD)
#define BUFFER_SIZE 5601
// Максимальная длина имени для таблицы: table_index - максимальная длина равна 9 (6 под table_, максимум 2 под индекс (изучаем только слова двузначной длины) и 1 под '\0')
#define LONGEST_TABLE_NAME 9

// суффикс временных файлов, которые будут удалены после использования
#define TMP_SUFFIX "_temporary_file__"
// Имя временного файла для хранения и чтения параметров конфигурации
#define TMP_PARAMS_FILE "__params_temporary_file__.txt"

/*
В книге рекордов Гиннеса самым длинным словом русского языка объявлено «рентгеноэлектрокардиографического», в нем – 33 знака. Это был рекорд 1933-го года. 
А в 2003 году его заменило слово из 35 символов – «превысокомногорассмотрительствующий».
Есть и более длинные слова, особенно много их в химии (т.к. там названия многосоставные). Но таких слов очень мало и запоминать их нет смысла.
Даже если длинное слово встретится в тексте, то скорее всего не удастся подобрать ему более короткой замены, если только не установить очень большой threshold
*/
#define MAX_AVAILABLE_WORD_LENGTH 35
// Сколько максимум может быть пропущено букв (size_tol)
#define MAX_AVAILABLE_MISSES 3
// Сколько максимум букв могут быть с опечаткой (threshold)
#define MAX_AVAILABLE_ERRORS 5

// Индикатор того, что новое слово вставилось в связный список
// Значение EXIT_SUCCESSFULLY - слово вставилось (или оно уже было), значение EXIT_MEMORY_FAILURE - слово не вставилось (ошибка памяти при создании нового узла)
extern int NEW_WORD_ADDED;
// Во сколько раз число слов в таблице должно превысить число строк, чтобы таблица автоматически увеличилась при добавлении нового слова
#define WRDS_EXCEED 10
// Во сколько раз увеличивать таблицу, если число слов в WRDS_EXCEED раз превышает число строк
#define HT_INCRS 2
// Размер строк, изначально выделяемый для каждой таблицы в корректоре
#define INITIAL_TABLE_SIZE 100

// Код первой заглавной буквы английского алфавита
#define FIRST_ENG_CAPITAL (int)'A'
// Код последней заглавной буквы английского алфавита
#define LAST_ENG_CAPITAL (int)'Z'
// Код первой строчной буквы английского алфавита
#define FIRST_ENG_LOWER (int)'a'
// Код последней строчной буквы английского алфавита
#define LAST_ENG_LOWER (int)'z'
// Код первой заглавной буквы русского алфавита
#define FIRST_RUS_CAPITAL (int)'А'
// Код последней заглавной буквы русского алфавита
#define LAST_RUS_CAPITAL (int)'Я'
// Код первой строчной буквы русского алфавита
#define FIRST_RUS_LOWER (int)'а'
// Код последней строчной буквы русского алфавита
#define LAST_RUS_LOWER (int)'я'
// Код буквы Ё (в некоторых кодировках она отдельно от остальной кириллицы
#define YO_CAPITAL (int)'Ё'
// Код буквы ё (в некоторых кодировках она отдельно от остальной кириллицы
#define YO_LOWER (int)'ё'

// Вывести пользователю, что его файл не является файлом с моделью
#define NOT_MODEL_FILE_MSG printf("Похоже, файл не является файлом с моделью. Исправьте файл или выберите другой и повторите попытку. Выполнение программы прекращено\n");
// Не выделилась память при загрузке модели из файла
#define LOAD_MEMORY_ERROR printf("Не удалось выделить память для модели. Приносим свои извинения!\nПовторите попытку\n");


#endif