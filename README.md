# TextCorrector
## НГУ. ФФ. Физическая информатика
### Структурное программирование. 3 семестр. Проект
### TextCorrector
Программа для поиска и исправления орфографических ошибок в тексте. Работает с файлами формата `.txt`
#### Что делает:
- Программа для редактирования текста.
- Работа через консоль.
- В параметрах при запуске передаётся путь к редактируемому файлу.
- Отредактированный файл сохраняется под требуемым именем.
#### Как делает:
- В основе лежит модель, запоминающая существующие слова по набору текстов на этапе обучения.
- При редактировании текста заменяет незнакомые слова в тексте на максимально похожие выученные (стратегию см. далее).

__WARNING: ИМЕНА ФАЙЛОВ НЕ ДОЛЖНЫ СОДЕРЖАТЬ `_temporary_file__`, ИНАЧЕ ОНИ МОГУТ БЫТЬ УДАЛЕНЫ!!!__

ФАЙЛЫ, СОДЕРЖАЩИЕ РУССКИЕ СИМВОЛЫ, ДОЛЖНЫ ИМЕТЬ КОДИРОВКУ ANSI. Это касается и файлов с конфигурацией. Для файлов, состоящих только из английских слов, допустима кодировка UTF-8. При сохранении модели или отредактированного текста кодировка ANSI устанавливается для файла автоматически. При чтении существующей модели или текста кодировка должна быть установлена пользователем.

Для лучшего обучения рекомендуется заменить в обучающих текстах символы «»„“ на обычные двойные кавычки ", символ ’ на обычный апостроф ', а … (троеточие одним знаком) на три отдельные точки ... . Это можно быстро сделать при помощи автозамены (`Ctrl+H` -> заменить все)
 
Слова хранятся в хеш-таблицах. Каждая хеш-таблица хранит слова одной и той же длины. Коллизии решаются с использованием связных списков. На этапе обучения слова, содержащие символы, кроме русских и английских букв, не запоминаются.

- Редактирование:

Слова длины 1 не заменяются! Т.к. пользователь может захотеть написать любой неосмысленный символ.

Первоначально при редактировании слова алгоритм проверяет в таблице со словами соответствующей длины, существует ли такое слово. Если находит, то ничего не меняет. 

Если же такого слова нет, то нужно найти максимально "близкое" слово. Алгоритм проходит по таблицам изученных слов такой же длины +-`size_tol` (максимально допустимое отклонение в длине слова, нужно задать в параметрах) и для каждого варианта считает отклонение от заменяемого слова. Из всех слов выбирается то, которое имеет минимальное отклонение.

- Почему хеш-таблица?

Во-первых, вставка элемента в хеш-таблицу происходит практически за O(1) операций (немного больше, т.к. возможны коллизии), а на этапе обучения нам нужно вставлять много слов. Во-вторых, предполагается, что большинство слов в редактируемом тексте всё же будут написаны правильно, поэтому желательно быстро уметь находить их среди изученных. Хеш-таблица позволяет сделать это также за O(1) (с поправкой на коллизии). Если же слово не нашлось, то придётся перебирать все возможные варианты замены. В таком случае любая структура будет осуществлять поиск примерно за O(N).

- Отклонение:

Отклонение считается как количество различающихся букв в соответствующих позициях (расстояние Хэмминга). При этом если минимальное отклонение больше, чем заданный параметр `threshold`, то слово также остаётся без изменений, т.к. ему не удалось подобрать адекватную замену. На этапе обучения для каждого слова подсчитывается количество раз, которое оно встретилось. Это значение хранится в списке вместе с самим словом. Если два или более слов имеют одинаковое отклонение от заменяемого, то выбирается чаще встречающееся. Если таких несколько одинаковых - выбирается первое встретившееся при поиске замены. Если длина редактируемого слова больше, чем max_word_length + threshold, то оно не редактируется.

- Регистр:

Все слова хранятся в нижнем регистре, поэтому исправление маленьких букв на заглавные в именах собственных не предусмотрена. Слова сравниваются без учёта регистра. Если в ИЗУЧАЕМОМ слове есть заглавные буквы, слово всё равно сохраняется со всеми маленькими. Если в РЕДАКТИРУЕМОМ слове более одной заглавной буквы, и первая тоже заглавная, то предполагается, что это какое-то сокращение или аббревиатура, и слово остаётся без изменений (т.к. невозможно догадаться, что сократил пользователь). Если первая буква прописная, то все остальные заглавные заменяются на прописную. Если только первая буква заглавная, то отредактированное слово тоже будет с заглавной буквы.

- Небуквенные символы в слове:

Небуквенный символ может возникнуть по четырём причинам: 

1. дефис в слове
2. знаки препинания после слова или перед словом пишутся с ним слитно (например, точка в конце или кавычка в начале)
3. пользователь написал слово, поставил знак препинания и забыл поставить пробел перед следующим словом
4. пользователь вместо буквы написал знак препинания

Первые два случая - нормальные, третий  и четвёртый - ошибки. Т.к. обучение происходит на текстах, которым пользователь доверяет, то предполагается, что там нет ошибок (не может быть ошибки_4). Поэтому если пунктуационные знаки в начале и в конце - они отбрасываются при ОБУЧЕНИИ (в т.ч. отбрасываются дефисы по краям). Если после этого в слове встречается небуквенный символ, кроме дефиса (дефис внутри слова допустим), то если это дефис (пунктуационный, но не буквенный), то слово запоминается вместе с ним (допустимо несколько дефисов в слове, но только не подряд), а если другой символ (например, цифра) или несколько дефисов подряд, то слово не запоминается. Может возникнуть следующая проблема: если после max_word_length (см. далее в разделе Параметры) символов следующим идёт дефис, то даже если дефис в конце слова, то программа не может понять, что это конец слова, и предполагает, что после дефиса слово продолжится. Т.о., если в max_word_length+1 стоит дефис, то слово признаётся слишком длинным и не учится, даже если этот дефис в конце слова. При этом если дефис стоит в позиции max_word_length (максимально допустимой), а далее идёт пробел или недефисный знак препинания, то дефис отбрасывается и слово без него анализируется, нужно ли его запоминать (т.к. помимо дефиса в том же слове могут быть цифры и т.п., такие слова не запоминаются).

Если небуквенный символ встречается на этапе РЕДАКТИРОВАНИЯ, то делим слова всеми небуквенными символами, кроме, возможно, дефисов (дефисы внутри слова позволительны). Таким образом, словом считается только последовательность букв и дефисов, причём дефисы не могут быть скраю слова и два дефиса не могут идти подряд. Если небуквенный символ не дефис, то он считается разделителем слов. Дефисы скраю слов тоже считаются самостоятельными символами. Если все буквенные символы - дефисы внутри слова (даже если они вдруг идут подряд), но такого слова с дефисом нет в корректоре, то слово записывается без изменений, т.к. это может быть сложное составное слово (типо серо-буро-малиновый) или какой-то шифр (например, корр--тор). В таких случаях мы бессильны. Таким образом, вариант ошибки 4 не предусмотрен. Причиной тому слишком большая неопределённость ошибки. На вход может поступить текст вообще состоящий из всех слов, написанных через запятую, но без пробелов, тогда получается слишком много вариантов для перебора, где запятая должна быть запятой, а где вместо запятой должна стоять буква.

#### Параметры, определение конфигурации работы программы
ВСЕ ПАРАМЕТРЫ ДОЛЖНЫ БЫТЬ РАЗДЕЛЕНЫ ПРОБЕЛАМИ!

ДВОЙНЫЕ кавычки позволительны (даже обязательны, если параметр - это некоторый путь, содержащий пробелы). Если параметр написан без кавычек - он читается до первого пробела. Если параметр в двойных кавычках - он читается от открывающей до закрывающей кавычки.

Первый параметр при запуске - режим ввода конфигурации
1. `params`
2. `step_by_step` (если параметров нет, то запускается также этот режим)
3. `from_file`
4. `help` - вывести справку
- В режиме `params` вся конфигурация должна быть задана в параметрах вызова
- В режиме `step_by_step` больше никаких параметров нет, по крайней мере мы их не обрабатываем. Пользователя последовательно просят ввести все параметры в консоль. Пользователю даются некоторые пояснения и несколько попыток корректно ввести требуемые параметры конфигурации
- В режиме `from_file` единственный следующий параметр - путь к файлу с конфигурацией (чтобы каждый раз не вводить параметры). __Имя файла не должно содержать `_temporary_file__`, иначе он может быть удалён!!!__

Далее надо определиться с режимом работы:
- `train_new` - обучение новой модели
- `train_existed` - дообучение существующей модели
- `edit` - редактирование текста

В режиме `train_new` нужны:
- путь для сохранения модели в формате __*.txt__ (вместе с новым именем)
- путь к обучающему тексту в формате __*.txt__
- максимальная длина запоминаемых слов (`max_word_size`). От 1 до 35

В режиме `train_existed` нужны:
- путь к существующей модели в формате __*.txt__
- путь к обучающему тексту в формате __*.txt__

В режиме `edit` нужны:
- путь к обученной модели в формате __*.txt__
- путь к редактируемому файлу в формате __*.txt__
- путь для сохранения отредактированного файла в формате __*.txt__ (вместе с новым именем)
- максимально допустимое отклонение длины заменяющего слова от заменяемого (`size_tol`). От 0 до 3
- максимально допустимая разность слов (`threshold`). Если разница для минимально отличающегося слова превышает этот порог, то слово остаётся в тексте без изменений (не удалось подобрать адекватную замену). От 0 до 3

#### Как выглядит окончательный конфиг
В режиме `train_new`:
1. Метка режима, 0, тип int
2. Путь для сохранения новой модели, строка (char*)
3. Путь к обучающему тексту, строка (char*)
4. Максимальная длина запоминаемых слов (`max_word_length`)

В режиме `train_existed` (т.к. модель существующая, то параметр `max_word_length` был задан ранее и записан в файл с моделью; он будет установлен при чтении модели из файла, в cfg его писать не нужно):
1. Метка режима, 1, тип int
2. Путь к существующей модели, строка (char*)
3. Путь к обучающему тексту, строка (char*)

В режиме `edit`:
1. Метка режима, 2, тип int
2. Путь к обученной модели
3. Путь к редактируемому тексту
4. Путь для сохранения отредактированного текста (путь вместе с именем)
5. Максимально допустимое отклонение длины заменяющего слова от заменяемого (`size_tol`)
6. Максимально допустимая разность слов (`threshold`)


